#!/usr/bin/python3

import datetime
import glob
import http.client
import os
import pwd
import random
import subprocess
import sys
import tempfile
import threading
import time

import netifaces

import keyboardleds

modem_device = '/dev/serial/by-id/usb-HUAWEI_HUAWEI_Mobile-if00-port0'
# keyboard_device = '/dev/input/by-path/platform-i8042-serio-0-event-kbd'
[keyboard_sys] = glob.glob('/sys/devices/platform/i8042/serio0/input/input*/event*')
keyboard_device = '/dev/input/' + os.path.basename(keyboard_sys)

def msg_start(msg):
    print(msg, end=': ')
    sys.stdout.flush()

def msg_ping():
    print('.', end='')
    sys.stdout.flush()

def msg_end(msg):
    print(msg)
    sys.stdout.flush()

def msg_now():
    now = datetime.datetime.now().replace(microsecond=0)
    msg_start('timestamp')
    msg_end(str(now))

def run(cmdline, shell=True):
    subprocess.check_call(cmdline, shell=shell)

def update_resolv_conf():
    path = '/proc/{pid}/ns/mnt'
    assert not os.path.samefile(
        path.format(pid=1),
        path.format(pid=os.getpid()),
    )
    with tempfile.NamedTemporaryFile(prefix='aero2-mananger.resolvconf.') as rdest:
        with open('resolv.conf', 'rb') as rsource:
            data = rsource.read()
        rdest.write(data)
        rdest.flush()
        run(['mount', '--bind', rdest.name, '/etc/resolv.conf'], shell=False)
    os.chmod('/etc/resolv.conf', 0o644)

def pgrep(command):
    for procdir in glob.glob('/proc/[0-9]*'):
        try:
            with open(procdir + '/cmdline', 'r') as file:
                pcmdline = file.read()
        except OSError:
            continue
        pcommand = pcmdline.split('\0', 1)[0]
        if pcommand == command:
            return True

def usb_modeswitch():
    msg_start('modem device')
    if not os.path.exists(modem_device):
        run('udevadm trigger --action=add --subsystem-match usb')
        while not os.path.exists(modem_device):
            msg_ping()
            time.sleep(1)
        msg_ping()
        time.sleep(1)
    assert os.path.exists(modem_device)
    msg_end(modem_device)

def net_down():
    msg_start('bringing network down')
    run('ifdown ppp-aero2')
    msg_ping()
    while pgrep('/usr/bin/wvdial'):
        time.sleep(1)
        msg_ping()
    msg_end('done')

def net_up():
    msg_start('bringing network up')
    run('ifup ppp-aero2')
    msg_ping()
    for i in range(15):
        try:
            netifaces.ifaddresses('ppp0')[netifaces.AF_INET]
        except (KeyError, ValueError):
            pass
        else:
            break
        time.sleep(1)
        msg_ping()
    else:
        msg_end('FAILED')
        return
    msg_end('done')

def abdicate():
    user = os.environ['SUDO_USER']
    userinfo = pwd.getpwnam(user)
    uid = userinfo.pw_uid
    gid = userinfo.pw_gid
    def switch_user():
        os.setgroups([])
        os.setgid(gid)
        os.setuid(uid)
    subprocess.check_call(['./abdicate', '--copy-to', 'captchas'], preexec_fn=switch_user)

def terror():
    msg_start('checking network')
    while True:
        msg_ping()
        try:
            conn = http.client.HTTPConnection('www.example.org')
            conn.request('HEAD', '/')
            response = conn.getresponse()
        except ConnectionError:
            time.sleep(0.5 + random.random())
            continue
        terror = (
            response.status == 302 and
            response.getheader('Location').startswith('http://bdi.')
        )
        msg_end('captcha redirect' if terror else 'ok')
        return terror

class Blinker(threading.Thread):

    def __init__(self):
        threading.Thread.__init__(self)
        self.event = threading.Event()
        self.led = keyboardleds.LedKit(keyboard_device).caps_lock

    def __enter__(self):
        self.start()
        return self

    def __exit__(self, tp, exc, tb):
        self.stop()

    def run(self):
        i = 0
        while True:
            i += 1
            if self.event.is_set():
                break
            if i % 2:
                self.led.set()
                self.event.wait(2.5)
            else:
                self.led.reset()
                self.event.wait(0.5)
        self.led.reset()

    def stop(self):
        self.event.set()

private_ns_token = 'AERO2_MANAGER_PRIVATE_NS'

def main():
    prefix = []
    if 'STY' not in os.environ:
        prefix += ['screen', '-d', '-R', 'aero2']
    if os.getuid() != 0:
        prefix += ['sudo', '-E', '-u', 'root']
    if private_ns_token not in os.environ:
        os.environ[private_ns_token] = '1'
        prefix += ['unshare', '-m']
    if prefix:
        os.execvp(prefix[0], prefix + [sys.executable, __file__] + sys.argv[1:])
    os.chdir(
        os.path.dirname(os.path.realpath(__file__))
    )
    update_resolv_conf()
    usb_modeswitch()
    last_address = None
    while 1:
        try:
            address = netifaces.ifaddresses('ppp0')
            [address] = address[netifaces.AF_INET]
            address = address['addr']
        except (KeyError, ValueError):
            address = None
        if address is None:
            net_down()
            net_up()
            continue
        if address != last_address:
            msg_start('IP')
            msg_end(address)
            last_address = address
            if terror():
                with Blinker() as blinker:
                    abdicate()
                if terror():
                    net_down()
                    net_up()
                    last_address = None
                blinker.join()
                msg_now()
                continue
        time.sleep(1 + random.random())

if __name__ == '__main__':
    main()

# vim:ts=4 sts=4 sw=4 et
